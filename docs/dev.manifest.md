## Development Manifest

### Use English

For comments and documentation we use English only.

### `%v`-wrapping by default

By default, try to wrap errors with `%v` (not `%w`) to avoid accidental abstraction leakage:

```go
return fmt.Errorf("create failed job: %v", err)
```

### Architecture

https://textik.com/#05a221397387733b

```       
                       +-------------------------+       
                       | API Handlers (HTTP now) |   
                       +-------------------------+       
                                    |                    
                                    |                    
                                    v                    
                 +--------------------------------------+
                 |   Usecases / Application Services    |
                 +--------------------------------------+
                     |           |             |         
                     |           |             |         
                     |           |             |         
                     v           |             v         
+-------------------------+      |    +-----------------+
| Infrastructure Services |      |    | Domain Services |
+-------------------------+      |    +-----------------+
            |                    |             |         
            |                    |             |         
            |                    |             |         
            v                    v             v         
+-----------------------+    +--------------------------+
|  Clients to           |    |        Repository        |
|     External Systems  |    +--------------------------+
+-----------------------+                  |             
                                           |             
                                           v             
                              +-------------------------+
                              | Generated storage (ent) |
                              +-------------------------+
```

### Validation & constructor generation

1) Try to validate input data on every architecture layer. <br>
2) Validate input data in constructors.
3) Avoid manual validations in favor of generated code or external libraries. <br>
   (https://github.com/go-playground/validator)

### Package naming & importing

Lowercase only, writing together, duplication of letters is ok.

```go
package freehandssignal
```

### Directory naming

Words in the directory name are separated by `-`, not by `_`.

```go
import (
    freehandssignal ".../internal/usecases/manager/free-hands-signal"
)
```

### Use camelCase JSON for inter-service interaction

https://google.github.io/styleguide/jsoncstyleguide.xml#Property_Name_Format

```json
{
  "authorId": "7d67b14d-221e-4499-9be2-6707d7df1adc",
  "createdAt": "2022-08-17T07:55:48.357139+03:00",
  "id": "ba5ee42d-1f1a-4f69-904a-c0c319c2a0ec",
  "isBlocked": false
}
```

### Unexported interfaces

Unexported (private) interfaces can be used as struct's dependencies.

Main reason why is that interface as dependency makes an opportunity to create mock and easily write unit test with full
coverage.
Also struct's dependencies won't be used outside of package, so there is no need to make them exported.

```go
// Generate mocks to write unit tests.
//go:generate mockgen -source=$GOFILE -destination=mocks/some_struct_mocks.gen.go -package=mocks

// Interface dependency1 is unexported because nobody outside of package won't use it.
type dependency1 interface {
	DoSomething1()
}

// Just like this one.
type dependency2 interface {
	DoSomething2()
}

type SomeStruct struct {
	dep1 dependency1
	dep2 dependency2
}
```

### Avoid nil-pointers in favor of zero value

If possible as the absence of a value, use zero value for the type rather than a null pointer to the type.

```go
if req.Cursor != "" {
	// ...
}
```

### Generated files must have suffix `.gen.go`

- `types.gen.go`
- `handler_mocks.gen.go`
- etc.

### SQL Performance

Pay attention to the SQL generated by **ent** framework. <br>
This can be done with tests and
```
TEST_LOG_LEVEL=debug
TEST_PSQL_DEBUG=true
Program arguments: -test.v
```

#### Known problems

1) All queries contain `DISTINCT` by default. It dramatically decreases queries performance.
   See [issue](https://github.com/ent/ent/issues/999). <br>
   Solutions:
    - `.Unique(false)`;
    - template overriding;
    - **ent** interceptors with `Unique(false)`.

2) Try to select the certain fields required for the task:
```go
Select(chat.FieldClientID)
```
This will greatly reduce the load on the network.

### ENT queries style-guide

#### Query format

Format:
```go
r.db.Entity(ctx).Operation().
	OperationArg0().
	OperationArg1().
	OperationArg2().
	Done(ctx)
```

Examples:
```go
c, err := r.db.Chat(ctx).Query().
	Unique(false).
	Select(chat.FieldClientID).
	Where(chat.ID(chatID)).
	Only(ctx)
```

```go
j, err := r.db.Job(ctx).Create().
	SetName(name).
	SetPayload(payload).
	SetAvailableAt(availableAt).
	Save(ctx)
```

#### Group WHERE-clause

Bad:
```go
r.db.Problem(ctx).Query().
     Unique(false).
     Where(problem.ManagerID(managerID)).
     Where(problem.ResolvedAtIsNil()).
     Count(ctx)
```

Good:
```go
r.db.Problem(ctx).Query().
     Unique(false).
     Where(
         problem.ManagerID(managerID),
         problem.ResolvedAtIsNil(),
     ).
     Count(ctx)
```

### Grouping fields in structures

```go
type Options struct {
	reserveFor time.Duration `option:"mandatory" validate:"min=3s,max=10m"`
	tickPeriod time.Duration `option:"mandatory" validate:"min=1s,max=10s"`
	
	jobsRepo jobsRepository `option:"mandatory" validate:"required"`
	txtor    transactor     `option:"mandatory" validate:"required"`
}
```

1) Separate primitive fields and "complex dependencies".
2) In groups keep fields in alphabetical order.

### For services try to follow the following package structure

```
mycoolservice
├── api.go
├── api_fat_method.go
├── service.go
└── service_options.gen.go
```

### Return `nil` on context cancellation

In common case on context cancellation return `nil` instead of `ctx.Err()`. <br>
This will avoid the "extra" error in the place where the goroutine is launched (errgroup, etc.).

```go
select {
case <-ctx.Done():
	return nil
// ...
}
```

### Keep transactions as "short" as possible

**TL;DR:**
1. To avoid exhaustion of connections pool keep transactions as "short" as possible.
2. Do not make any unrelated to database things within transaction.
3. If you need such things use
   pattern ["transactional outbox"](https://microservices.io/patterns/data/transactional-outbox.html).

Each transaction reserves connection from pool during its running. So if some transactions last for a long time, they
could lead to lack of connections in the pool. E.g. other client will come with its request, there are no connections
in the pool, with high probability client will get timeout error, because all connections are busy.

Universal rule is to keep inside transactions only database queries (also short and fast ones) or simple calculations.
Avoid network requests or interactions with other application components (queues, message brokers, etc.) or something
else that is unrelated to database. Lags or glitches of external components could affect databases availability.

There could be necessity to atomically write something to database and make something "dangerous" like network request
inside transaction. Pattern ["transactional outbox"](https://microservices.io/patterns/data/transactional-outbox.html)
allows to do such thing without risks to create long-running transaction.

1. Begin transaction.
2. Write something to database.
3. Write "job" to do network request to special "outbox" table in database.
4. Commit transaction.
5. ...
6. Other process or coroutine _asynchronously_ processes "outbox" table and runs "jobs" from it.
